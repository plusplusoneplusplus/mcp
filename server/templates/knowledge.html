{% extends "base.html" %}

{% block title %}Knowledge Management - MCP Knowledge Server{% endblock %}

{% block extra_styles %}
<style>
    /* Knowledge-specific styles */
    .tabs {
        display: flex;
        gap: 0.5em;
        margin-bottom: 1.5em;
        margin-left: 2em;
    }

    .tab-btn {
        background: #eee;
        border: none;
        border-radius: 6px 6px 0 0;
        padding: 0.7em 1.5em;
        font-size: 1em;
        cursor: pointer;
        color: #333;
        transition: background 0.2s, color 0.2s;
    }

    .tab-btn.active {
        background: #fff;
        color: #0077cc;
        border-bottom: 2px solid #fff;
        font-weight: bold;
        box-shadow: 0 -2px 8px #eee;
    }

    .tab-content {
        display: block;
        width: 100vw;
        margin: 0;
    }

    .import-path-info {
        font-size: 0.95em;
        color: #555;
        margin-bottom: 1em;
        margin-left: 2em;
    }

    /* Sync-specific styles */
    .sync-status {
        padding: 10px;
        border-radius: 4px;
        margin: 10px 0;
    }
    .sync-status.sync-success {
        background-color: #d4edda;
        border: 1px solid #c3e6cb;
        color: #155724;
    }
    .sync-status.sync-error {
        background-color: #f8d7da;
        border: 1px solid #f5c6cb;
        color: #721c24;
    }
    .sync-status.sync-info {
        background-color: #d1ecf1;
        border: 1px solid #bee5eb;
        color: #0c5460;
    }
    .sync-folder-item {
        background-color: white;
        border: 1px solid #ddd;
        border-radius: 4px;
        padding: 15px;
        margin: 10px 0;
    }
    .sync-folder-path {
        font-family: monospace;
        background-color: #f8f9fa;
        padding: 5px;
        border-radius: 3px;
    }

    /* Code indexing specific styles */
    .code-indexing-section {
        background-color: white;
        border: 1px solid #ddd;
        border-radius: 4px;
        padding: 15px;
        margin: 10px 0;
    }
    .code-indexing-result {
        background-color: #f8f9fa;
        border: 1px solid #dee2e6;
        border-radius: 4px;
        padding: 10px;
        margin: 10px 0;
        font-family: monospace;
        font-size: 0.9em;
        max-height: 400px;
        overflow-y: auto;
    }
    .indexing-option {
        border: 2px solid #ddd;
        border-radius: 6px;
        padding: 15px;
        margin: 15px 0;
        cursor: pointer;
        transition: border-color 0.2s, background-color 0.2s;
    }
    .indexing-option:hover {
        border-color: #0077cc;
        background-color: #f8f9fa;
    }
    .indexing-option.selected {
        border-color: #0077cc;
        background-color: #e7f3ff;
    }
    .option-title {
        font-weight: bold;
        font-size: 1.1em;
        color: #0077cc;
    }
    .option-description {
        margin-top: 5px;
        color: #666;
    }

    /* Code viewer specific styles */
    .path-selector {
        background-color: #f8f9fa;
        border: 1px solid #dee2e6;
        border-radius: 8px;
        padding: 20px;
        margin-bottom: 20px;
    }

    .indexed-paths-list {
        max-height: 300px;
        overflow-y: auto;
        border: 1px solid #ddd;
        border-radius: 4px;
        margin: 10px 0;
    }

    .path-item {
        padding: 12px 15px;
        border-bottom: 1px solid #eee;
        cursor: pointer;
        transition: background-color 0.2s;
    }

    .path-item:hover {
        background-color: #f0f8ff;
    }

    .path-item.selected {
        background-color: #e7f3ff;
        border-left: 4px solid #0077cc;
    }

    .path-item:last-child {
        border-bottom: none;
    }

    .path-original {
        font-family: monospace;
        font-weight: bold;
        color: #0077cc;
        font-size: 1.1em;
    }

    .path-meta {
        font-size: 0.85em;
        color: #666;
        margin-top: 4px;
    }

    .search-section {
        background-color: white;
        border: 1px solid #dee2e6;
        border-radius: 8px;
        padding: 20px;
        margin-bottom: 20px;
    }

    .search-input {
        width: 100%;
        padding: 10px 15px;
        border: 2px solid #ddd;
        border-radius: 6px;
        font-size: 1em;
        transition: border-color 0.2s;
    }

    .search-input:focus {
        outline: none;
        border-color: #0077cc;
        box-shadow: 0 0 0 3px rgba(0, 119, 204, 0.1);
    }

    .file-path {
        font-family: monospace;
        background-color: #f1f3f4;
        padding: 2px 6px;
        border-radius: 3px;
        font-size: 0.9em;
    }

    .line-number {
        color: #666;
        font-size: 0.85em;
    }

    .source-badge {
        display: inline-block;
        background-color: #e1f5fe;
        color: #0277bd;
        padding: 2px 8px;
        border-radius: 12px;
        font-size: 0.8em;
        font-weight: bold;
        text-transform: capitalize;
    }

    .uml-expand-toggle {
        cursor: pointer;
        color: #0077cc;
        text-decoration: underline;
        font-style: italic;
        user-select: none;
        transition: color 0.2s;
    }

    .uml-expand-toggle:hover {
        color: #005aa3;
        background-color: rgba(0, 119, 204, 0.1);
        padding: 2px 4px;
        border-radius: 3px;
    }

    .uml-expanded-section {
        display: none;
    }

    .uml-expanded-section.visible {
        display: block;
    }

    .uml-collapse-toggle {
        cursor: pointer;
        color: #666;
        text-decoration: underline;
        font-style: italic;
        user-select: none;
        transition: color 0.2s;
    }

    .uml-collapse-toggle:hover {
        color: #333;
    }

    .uml-toggle-section {
        display: block;
    }

    .uml-toggle-section.hidden {
        display: none;
    }

    .class-results {
        margin-top: 20px;
    }

    .class-card {
        background: white;
        border: 1px solid #dee2e6;
        border-radius: 8px;
        padding: 15px;
        margin-bottom: 15px;
        box-shadow: 0 2px 4px rgba(0,0,0,0.1);
    }

    .class-name {
        font-family: monospace;
        font-size: 1.2em;
        font-weight: bold;
        color: #0077cc;
        margin-bottom: 8px;
    }

    .class-info {
        font-size: 0.9em;
        color: #666;
        margin-bottom: 10px;
    }

    .uml-diagram {
        background: #f8f9fa;
        border: 1px solid #dee2e6;
        border-radius: 4px;
        padding: 15px;
        font-family: monospace;
        font-size: 0.9em;
        white-space: pre-wrap;
        max-height: 400px;
        overflow-y: auto;
    }

    .no-results {
        text-align: center;
        padding: 40px;
        color: #666;
        font-style: italic;
    }

    .loading {
        text-align: center;
        padding: 20px;
        color: #0077cc;
    }

    .error {
        background-color: #f8d7da;
        border: 1px solid #f5c6cb;
        color: #721c24;
        padding: 15px;
        border-radius: 4px;
        margin: 10px 0;
    }

    .search-stats {
        background-color: #d1ecf1;
        border: 1px solid #bee5eb;
        color: #0c5460;
        padding: 10px;
        border-radius: 4px;
        margin: 10px 0;
        font-size: 0.9em;
    }
</style>
{% endblock %}

{% block content %}
<div class="import-path-info">
    <b>Knowledge Import Path:</b> <code>{{ import_path }}</code>
</div>

<div class="tabs">
    <button class="tab-btn active" data-tab="import-tab">Import</button>
    <button class="tab-btn" data-tab="list-tab">List</button>
    <button class="tab-btn" data-tab="query-tab">Query</button>
    <button class="tab-btn" data-tab="collections-tab">Collections</button>
    <button class="tab-btn" data-tab="sync-tab">Sync</button>
    <button class="tab-btn" data-tab="code-indexing-tab">Code Indexing</button>
    <button class="tab-btn" data-tab="code-viewer-tab">Code Viewer</button>
</div>

<!-- Import Tab -->
<div class="tab-content" id="import-tab">
    <div class="card">
        <h2>Import Knowledge Directory</h2>
        <form id="import-form" enctype="multipart/form-data">
            <label for="import-files" style="font-weight:bold;">Select Folder:</label>
            <div style="margin-bottom:0.5em;">
                <span style="font-size:0.97em;">Include file extensions:</span>
                <label style="margin-left:1em;"><input type="checkbox" class="ext-filter" value=".md" checked>
                    .md</label>
                <label style="margin-left:0.5em;"><input type="checkbox" class="ext-filter" value=".txt"> .txt</label>
                <label style="margin-left:0.5em;"><input type="checkbox" class="ext-filter" value=".rst"> .rst</label>
                <label style="margin-left:0.5em;"><input type="checkbox" class="ext-filter" value=".docx"> .docx</label>
                <label style="margin-left:0.5em;"><input type="checkbox" class="ext-filter" value=".pdf"> .pdf</label>
            </div>
            <input type="file" id="import-files" name="files" webkitdirectory directory accept=".md" style="margin-bottom:1em;" />
            <div id="selection-help" style="font-size:0.9em; color:#666; margin-bottom:0.5em;">Click "Choose Files" to select a folder. All files with selected extensions in the folder and subfolders will be imported.</div>
            <div id="selected-folder-path" style="font-size:0.95em; color:#666; margin:0.5em 0 0.2em 0;"></div>
            <div id="selected-files-list" style="margin:0.2em 0 0.5em 0;"></div>
            <label>Collection name (optional): <input type="text" name="collection" /></label>
            <div style="margin:0.5em 0;">
                <label><input type="checkbox" id="import-overwrite" name="overwrite" value="true"> Overwrite collection
                    (delete all existing documents first)</label>
            </div>
            <button type="submit" style="margin-left:1em;">Import</button>
        </form>
        <div id="import-status" style="margin-top:1em;"></div>
    </div>
</div>

<!-- List Tab -->
<div class="tab-content" id="list-tab" style="display:none;">
    <div class="card">
        <h2>List Documents in Collection</h2>
        <label for="collections-dropdown">Select collection:</label>
        <select id="collections-dropdown"></select>
        <button id="list-docs-btn">List Documents</button>
        <div id="docs-status" style="margin-top:1em;"></div>
        <div id="doc-viewer-area" style="margin-top:1em; display:none;">
            <label for="doc-selector" style="font-family:monospace;">Select document:</label>
            <select id="doc-selector" style="font-family:monospace;"></select>
            <br><br>
            <textarea id="doc-content-area" rows="24"
                style="width:100%;font-family:monospace;resize:vertical;"></textarea>
            <br>
            <label for="doc-metadata-area" style="font-family:monospace;">Metadata:</label>
            <textarea id="doc-metadata-area" rows="8" style="width:100%;font-family:monospace;resize:vertical;"
                readonly></textarea>
        </div>
    </div>
</div>

<!-- Query Tab -->
<div class="tab-content" id="query-tab" style="display:none;">
    <div class="card">
        <h2>Query Segments (Semantic Search)</h2>
        <label for="query-collections-dropdown">Select collection:</label>
        <select id="query-collections-dropdown"></select>
        <br><br>
        <label for="query-text">Query:</label>
        <input type="text" id="query-text" size="40" placeholder="Enter your intention or question..." />
        <br><br>
        <label for="query-limit">Number of results:</label>
        <input type="number" id="query-limit" min="1" max="20" value="3" style="width:4em;" />
        <button id="run-query-btn">Search</button>
        <div id="query-status" style="margin-top:1em;"></div>
        <ul id="query-results"></ul>
    </div>
</div>

<!-- Collections Tab -->
<div class="tab-content" id="collections-tab" style="display:none;">
    <div class="card">
        <h2>Manage Collections</h2>
        <div id="collections-list-area" style="margin-top:1em;"></div>
    </div>
</div>

<!-- Sync Tab -->
<div class="tab-content" id="sync-tab" style="display:none;">
    <div class="card">
        <h2>Configuration Status</h2>
        <div id="sync-status-info" class="sync-status sync-info">Loading configuration...</div>
        <button id="refresh-sync-status-btn" style="background:#007bff;color:white;border:none;padding:0.5em 1em;border-radius:4px;cursor:pointer;margin:0.5em 0;">Refresh Status</button>
    </div>

    <div class="card" id="sync-controls" style="display:none;">
        <h2>Sync Controls</h2>

        <div style="margin:1em 0;">
            <button id="sync-btn" style="background:#007bff;color:white;border:none;padding:0.7em 1.2em;border-radius:4px;cursor:pointer;margin:0.3em;">
                <span class="sync-loading" id="sync-loading" style="display:none;">⏳</span>
                Sync Folders
            </button>
            <button id="resync-btn" style="background:#dc3545;color:white;border:none;padding:0.7em 1.2em;border-radius:4px;cursor:pointer;margin:0.3em;">
                <span class="sync-loading" id="resync-loading" style="display:none;">⏳</span>
                Re-sync (Clear & Rebuild)
            </button>
        </div>

        <div id="sync-results"></div>
    </div>

    <div class="card" id="folder-list" style="display:none;">
        <h2>Configured Folders</h2>
        <ul id="sync-folders" style="list-style-type:none;padding:0;"></ul>
    </div>
</div>

<!-- Code Indexing Tab -->
<div class="tab-content" id="code-indexing-tab" style="display:none;">
    <div class="card">
        <h2>Code Indexing</h2>
        <p>Index your source code using different methods. Results will be saved to a <code>server/.code_indexing/[hash]</code> subfolder, where [hash] is based on your source path.</p>
        <p><strong>Note:</strong> If the directory is under git version control, only git-tracked files will be indexed. Non-git directories will process all files.</p>

        <div class="code-indexing-section">
            <label for="source-path-input" style="font-weight:bold;">Source Directory Path:</label>
            <input type="text" id="source-path-input" placeholder="/path/to/your/project" style="width:100%; padding:8px; margin:10px 0; border:1px solid #ddd; border-radius:4px;">
        </div>

        <div class="code-indexing-section">
            <h3>Choose Indexing Method:</h3>

            <div class="indexing-option" data-method="ctags">
                <div class="option-title">🏷️ CTags + Outline Generation</div>
                <div class="option-description">
                    Generates comprehensive tags using Universal CTags and creates a structured outline.
                    <br><strong>Features:</strong> Function definitions, classes, variables, file structure
                    <br><strong>Languages:</strong> C++, Python, JavaScript, Java and more
                </div>
            </div>

            <div class="indexing-option" data-method="tree-sitter">
                <div class="option-title">🌳 Tree-Sitter Parsing</div>
                <div class="option-description">
                    Advanced syntax tree parsing for deep code analysis and relationships.
                    <br><strong>Features:</strong> Function calls, class hierarchies, detailed AST analysis
                    <br><strong>Languages:</strong> C++, Python, JavaScript, Java
                </div>
            </div>
        </div>

        <div class="code-indexing-section" id="ctags-options" style="display:none;">
            <h4>CTags Options</h4>
            <label for="languages-input">Languages (comma-separated):</label>
            <input type="text" id="languages-input" value="C++,Python,JavaScript,Java" style="width:100%; padding:8px; margin:5px 0; border:1px solid #ddd; border-radius:4px;">
        </div>

        <button id="start-indexing-btn" style="background:#28a745;color:white;border:none;padding:12px 24px;border-radius:4px;cursor:pointer;font-size:1em;margin:15px 0;" disabled>
            Start Indexing
        </button>

        <div id="indexing-status" style="margin:15px 0;"></div>
        <div id="indexing-results" style="margin:15px 0;"></div>
    </div>
</div>

<!-- Code Viewer Tab -->
<div class="tab-content" id="code-viewer-tab" style="display:none;">
    <div class="card">
        <h2>Code Viewer</h2>
        <p>Browse indexed code repositories and search for class definitions with UML-like visualization.</p>

        <!-- Path Selection Section -->
        <div class="path-selector">
            <h3>📁 Select Indexed Path</h3>
            <p>Choose from the indexed code repositories below:</p>

            <div id="cv-paths-loading" class="loading">
                ⏳ Loading indexed paths...
            </div>

            <div id="cv-paths-error" class="error" style="display: none;">
                ❌ Error loading paths
            </div>

            <div id="cv-paths-container" style="display: none;">
                <div class="indexed-paths-list" id="cv-indexed-paths">
                    <!-- Paths will be populated here -->
                </div>

                <div id="cv-selected-path-info" style="display: none;">
                    <h4>Selected Path Information:</h4>
                    <div id="cv-path-details"></div>
                </div>
            </div>
        </div>

        <!-- Class Search Section -->
        <div class="search-section" id="cv-search-section" style="display: none;">
            <h3>🔍 Search Class Definitions</h3>
            <p>Search for classes in the selected codebase:</p>

            <input type="text"
                   id="cv-class-search-input"
                   class="search-input"
                   placeholder="Search classes by name or file path (e.g., 'RedisModule', 'Table', '.py', 'utils/')"
                   autocomplete="off">

            <div id="cv-search-stats" class="search-stats" style="display: none;"></div>

            <div id="cv-search-results" class="class-results">
                <div class="no-results" id="cv-no-search-message">
                    Enter a class name above to search for definitions
                </div>
            </div>
        </div>
    </div>
</div>
{% endblock %}

{% block extra_scripts %}
<script>
    // --- Tab Switching ---
    document.querySelectorAll('.tab-btn').forEach(btn => {
        btn.addEventListener('click', function () {
            document.querySelectorAll('.tab-btn').forEach(b => b.classList.remove('active'));
            document.querySelectorAll('.tab-content').forEach(tc => tc.style.display = 'none');
            btn.classList.add('active');
            document.getElementById(btn.dataset.tab).style.display = 'block';
            if (btn.dataset.tab === 'collections-tab') loadCollectionsList();
            if (btn.dataset.tab === 'sync-tab') loadSyncStatus();
            if (btn.dataset.tab === 'code-viewer-tab') loadCodeViewerPaths();
        });
    });

    // --- Manage Collections Tab ---
    async function loadCollectionsList() {
        const area = document.getElementById('collections-list-area');
        area.innerHTML = 'Loading collections...';
        try {
            const resp = await fetch('/api/collections');
            const data = await resp.json();
            if (!data.collections || data.collections.length === 0) {
                area.innerHTML = '<span>No collections found.</span>';
                return;
            }
            let html = '<ul style="list-style:none;padding:0;">';
            data.collections.forEach(col => {
                html += `<li style='margin-bottom:0.7em;'><span style='font-family:monospace;'>${col}</span> <button class='delete-col-btn' data-col='${col}' style='color:#fff;background:#d9534f;border:none;border-radius:4px;padding:0.3em 0.8em;cursor:pointer;margin-left:1em;'>Delete</button></li>`;
            });
            html += '</ul>';
            area.innerHTML = html;
            document.querySelectorAll('.delete-col-btn').forEach(btn => {
                btn.addEventListener('click', async function () {
                    const col = btn.dataset.col;
                    if (!confirm(`Are you sure you want to delete collection '${col}'? This cannot be undone.`)) return;
                    btn.disabled = true;
                    btn.textContent = 'Deleting...';
                    const resp = await fetch('/api/delete-collection', {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify({ collection: col })
                    });
                    const result = await resp.json();
                    if (result.success) {
                        btn.parentElement.remove();
                    } else {
                        alert('Failed to delete: ' + (result.error || 'Unknown error'));
                        btn.disabled = false;
                        btn.textContent = 'Delete';
                    }
                });
            });
        } catch (err) {
            area.innerHTML = `<span style='color:red;'>Error loading collections: ${err}</span>`;
        }
    }


    // --- Import Extension Filters ---
    function updateImportAccept() {
        const fileInput = document.getElementById('import-files');
        const checked = Array.from(document.querySelectorAll('.ext-filter:checked')).map(cb => cb.value);
        fileInput.setAttribute('accept', checked.join(','));
        fileInput.dispatchEvent(new Event('change'));
    }
    document.querySelectorAll('.ext-filter').forEach(cb => {
        cb.addEventListener('change', updateImportAccept);
    });

    // --- Show Selected Files and Folder Name ---
    document.getElementById('import-files').addEventListener('change', function (e) {
        const files = Array.from(e.target.files);
        const listDiv = document.getElementById('selected-files-list');
        const folderDiv = document.getElementById('selected-folder-path');

        if (!files.length) {
            listDiv.innerHTML = '';
            folderDiv.innerHTML = '';
            return;
        }

        // Get selected extensions
        const exts = Array.from(document.querySelectorAll('.ext-filter:checked')).map(cb => cb.value);

        // Filter files by selected extensions
        const filtered = files.filter(f => exts.some(ext => f.name.toLowerCase().endsWith(ext.toLowerCase())));

        // Display folder information
        let folder = '';
        if (files[0] && files[0].webkitRelativePath) {
            folder = files[0].webkitRelativePath.split('/')[0];
            folderDiv.innerHTML = `<b>Selected folder:</b> <code>${folder}</code> <span title='Browsers do not expose the absolute path for security.' style='color:#888;'>(absolute path not available)</span>`;
        }

        // Display file list
        if (filtered.length === 0) {
            if (files.length > 0) {
                listDiv.innerHTML = `<span style="color:#666;">No files match the selected extensions. Found ${files.length} total files, but none have the selected extensions. Files will be ignored during import.</span>`;
            } else {
                listDiv.innerHTML = '<span style="color:#666;">No files found in the selected folder.</span>';
            }
            return;
        }

        // Group files by extension for better display
        const filesByExt = {};
        filtered.forEach(file => {
            const ext = exts.find(e => file.name.toLowerCase().endsWith(e.toLowerCase())) || 'other';
            if (!filesByExt[ext]) filesByExt[ext] = [];
            filesByExt[ext].push(file);
        });

        let html = `<b>Found ${filtered.length} matching files:</b>`;

        // Show breakdown by extension
        const extCounts = Object.entries(filesByExt).map(([ext, files]) => `${files.length} ${ext}`);
        html += `<div style="color:#666; font-size:0.9em; margin:0.2em 0;">${extCounts.join(', ')}</div>`;

        // Show file list (limited to first 15 for performance)
        html += '<ul style="margin:0.3em 0 0.3em 1em; max-height:200px; overflow-y:auto;">';
        const showFiles = filtered.slice(0, 15);
        for (const file of showFiles) {
            const displayName = file.webkitRelativePath || file.name;
            const ext = exts.find(e => file.name.toLowerCase().endsWith(e.toLowerCase())) || '';
            html += `<li><span style="color:#007acc;">${ext}</span> ${displayName}</li>`;
        }
        html += '</ul>';

        if (filtered.length > 15) {
            html += `<div style='color:#888; font-size:0.9em;'>...and ${filtered.length - 15} more files</div>`;
        }

        listDiv.innerHTML = html;
    });

    // --- Import Knowledge AJAX ---
    document.getElementById('import-form').addEventListener('submit', async function (e) {
        e.preventDefault();
        const statusDiv = document.getElementById('import-status');
        const fileInput = document.getElementById('import-files');
        const files = Array.from(fileInput.files);

        if (!files.length) {
            statusDiv.innerHTML = '<span style="color:red;">Please select a folder to import.</span>';
            return;
        }

        // Get selected extensions
        const exts = Array.from(document.querySelectorAll('.ext-filter:checked')).map(cb => cb.value);
        if (!exts.length) {
            statusDiv.innerHTML = '<span style="color:red;">Please select at least one file extension to import.</span>';
            return;
        }

        // Filter files by selected extensions
        const filtered = files.filter(f => exts.some(ext => f.name.toLowerCase().endsWith(ext.toLowerCase())));

        if (!filtered.length) {
            statusDiv.innerHTML = `<span style="color:orange;">No files match the selected extensions. Found ${files.length} total files, but none have the selected extensions. Nothing to import.</span>`;
            return;
        }

        statusDiv.innerHTML = `<span style='color:blue;'>Uploading and importing ${filtered.length} files (ignoring ${files.length - filtered.length} non-matching files)...</span>`;

        const form = e.target;
        const formData = new FormData();

        // Add only the filtered files to the form data
        filtered.forEach(file => {
            formData.append('files', file);
        });

        // Add other form fields
        const collection = form.querySelector('input[name="collection"]').value;
        const overwrite = form.querySelector('input[name="overwrite"]').checked;

        if (collection) {
            formData.append('collection', collection);
        }
        if (overwrite) {
            formData.append('overwrite', 'true');
        }

        try {
            const response = await fetch('/api/import-knowledge', {
                method: 'POST',
                body: formData
            });
            const result = await response.json();
            if (result.success) {
                statusDiv.innerHTML = `<span style='color:green;'>Successfully imported ${result.imported_files} files. Total segments stored: ${result.total_segments}.</span>`;
                form.reset();
                document.getElementById('selected-files-list').innerHTML = '';
                document.getElementById('selected-folder-path').innerHTML = '';

                await loadCollections();
            } else {
                statusDiv.innerHTML = `<span style='color:red;'>Error: ${result.error || 'Unknown error'}</span>`;
            }
        } catch (err) {
            statusDiv.innerHTML = `<span style='color:red;'>Unexpected error: ${err}</span>`;
        }
    });

    // --- Collections Dropdown and List Documents ---
    async function loadCollections() {
        const dropdown = document.getElementById('collections-dropdown');
        dropdown.innerHTML = '';
        try {
            const resp = await fetch('/api/collections');
            const data = await resp.json();
            if (data.collections && data.collections.length > 0) {
                data.collections.forEach(col => {
                    const opt = document.createElement('option');
                    opt.value = col;
                    opt.textContent = col;
                    dropdown.appendChild(opt);
                });
            } else {
                const opt = document.createElement('option');
                opt.value = '';
                opt.textContent = 'No collections';
                dropdown.appendChild(opt);
            }
        } catch (err) {
            const opt = document.createElement('option');
            opt.value = '';
            opt.textContent = 'Error loading collections';
            dropdown.appendChild(opt);
        }
    }

    document.getElementById('list-docs-btn').addEventListener('click', async function () {
        const dropdown = document.getElementById('collections-dropdown');
        const col = dropdown.value;
        const docsStatus = document.getElementById('docs-status');
        const docViewer = document.getElementById('doc-viewer-area');
        const docSelector = document.getElementById('doc-selector');
        const docContentArea = document.getElementById('doc-content-area');
        docViewer.style.display = 'none';
        docSelector.innerHTML = '';
        docContentArea.value = '';
        if (!col) {
            docsStatus.innerHTML = '<span style="color:red;">Please select a collection.</span>';
            return;
        }
        docsStatus.textContent = 'Loading documents...';
        try {
            const resp = await fetch(`/api/collection-documents?collection=${encodeURIComponent(col)}`);
            const data = await resp.json();
            if (data.error) {
                docsStatus.innerHTML = `<span style='color:red;'>Error: ${data.error}</span>`;
            } else if (data.documents && data.documents.length > 0) {
                docsStatus.innerHTML = `<span style='color:green;'>Found ${data.documents.length} documents.</span>`;
                docSelector.innerHTML = '';
                data.documents.forEach((doc, i) => {
                    const id = (data.ids && data.ids[i]) ? data.ids[i] : `#${i + 1}`;
                    const opt = document.createElement('option');
                    opt.value = i;
                    opt.textContent = id.length > 40 ? id.slice(0, 40) + '...' : id;
                    docSelector.appendChild(opt);
                });
                docContentArea.value = data.documents[0] || '';
                const docMetadataArea = document.getElementById('doc-metadata-area');
                function setMetadata(idx) {
                    const meta = (data.metadatas && data.metadatas[idx]) ? data.metadatas[idx] : undefined;
                    docMetadataArea.value = meta ? JSON.stringify(meta, null, 2) : '';
                }
                setMetadata(0);
                docViewer.style.display = '';
                docSelector.onchange = function () {
                    const idx = parseInt(this.value);
                    docContentArea.value = data.documents[idx] || '';
                    setMetadata(idx);
                };
            } else {
                docsStatus.innerHTML = '<span>No documents found in this collection.</span>';
                docViewer.style.display = 'none';
            }
        } catch (err) {
            docsStatus.innerHTML = `<span style='color:red;'>Unexpected error: ${err}</span>`;
            docViewer.style.display = 'none';
        }
    });

    // --- Query Segments (Semantic Search) ---
    async function loadQueryCollections() {
        const dropdown = document.getElementById('query-collections-dropdown');
        dropdown.innerHTML = '';
        try {
            const resp = await fetch('/api/collections');
            const data = await resp.json();
            if (data.collections && data.collections.length > 0) {
                data.collections.forEach(col => {
                    const opt = document.createElement('option');
                    opt.value = col;
                    opt.textContent = col;
                    dropdown.appendChild(opt);
                });
            } else {
                const opt = document.createElement('option');
                opt.value = '';
                opt.textContent = 'No collections';
                dropdown.appendChild(opt);
            }
        } catch (err) {
            const opt = document.createElement('option');
            opt.value = '';
            opt.textContent = 'Error loading collections';
            dropdown.appendChild(opt);
        }
    }

    document.getElementById('run-query-btn').addEventListener('click', async function () {
        const col = document.getElementById('query-collections-dropdown').value;
        const query = document.getElementById('query-text').value;
        const limit = document.getElementById('query-limit').value || 3;
        const statusDiv = document.getElementById('query-status');
        const resultsList = document.getElementById('query-results');
        resultsList.innerHTML = '';
        if (!col) {
            statusDiv.innerHTML = '<span style="color:red;">Please select a collection.</span>';
            return;
        }
        if (!query) {
            statusDiv.innerHTML = '<span style="color:red;">Please enter a query.</span>';
            return;
        }
        statusDiv.textContent = 'Searching...';
        try {
            const resp = await fetch(`/api/query-segments?collection=${encodeURIComponent(col)}&query=${encodeURIComponent(query)}&limit=${encodeURIComponent(limit)}`);
            const data = await resp.json();
            if (data.error) {
                statusDiv.innerHTML = `<span style='color:red;'>Error: ${data.error}</span>`;
            } else if (data.documents && data.documents.length > 0) {
                statusDiv.innerHTML = `<span style='color:green;'>Top ${data.documents.length} results:</span>`;
                data.documents.forEach((doc, i) => {
                    const li = document.createElement('li');
                    const meta = data.metadatas && data.metadatas[i] ? JSON.stringify(data.metadatas[i]) : '';
                    const score = data.distances && data.distances[i] !== undefined ? ` (distance: ${data.distances[i].toFixed(4)})` : '';
                    li.innerHTML = `<b>#${i + 1}</b> ${doc.length > 100 ? doc.slice(0, 100) + '...' : doc} <small>${meta}${score}</small>`;
                    resultsList.appendChild(li);
                });
            } else {
                statusDiv.innerHTML = '<span>No relevant segments found.</span>';
            }
        } catch (err) {
            statusDiv.innerHTML = `<span style='color:red;'>Unexpected error: ${err}</span>`;
        }
    });

    // Load collections on page load for both dropdowns
    loadCollections();
    loadQueryCollections();

    // --- Sync Tab Functions ---
    async function loadSyncStatus() {
        document.getElementById('sync-status-info').textContent = 'Loading...';

        try {
            const response = await fetch('/api/knowledge-sync/status');
            const data = await response.json();

            if (data.enabled) {
                document.getElementById('sync-status-info').className = 'sync-status sync-success';
                document.getElementById('sync-status-info').textContent =
                    `Knowledge sync is enabled. ${data.configured_folders} folders configured.`;

                document.getElementById('sync-controls').style.display = 'block';
                document.getElementById('folder-list').style.display = 'block';

                // Display folder list
                const foldersHtml = data.folders.map(folder => `
                    <li class="sync-folder-item">
                        <strong>Collection:</strong> ${folder.collection}<br>
                        <strong>Path:</strong> <span class="sync-folder-path">${folder.path}</span><br>
                        <strong>Resolved:</strong> ${folder.resolved_path || 'Not found'}
                        <button onclick="syncSingleFolder('${folder.path}', '${folder.collection}', false)" style="background:#007bff;color:white;border:none;padding:0.3em 0.8em;border-radius:4px;cursor:pointer;margin:0.3em;">Sync</button>
                        <button onclick="syncSingleFolder('${folder.path}', '${folder.collection}', true)" style="background:#dc3545;color:white;border:none;padding:0.3em 0.8em;border-radius:4px;cursor:pointer;margin:0.3em;">Re-sync</button>
                    </li>
                `).join('');

                document.getElementById('sync-folders').innerHTML = foldersHtml;
            } else {
                document.getElementById('sync-status-info').className = 'sync-status sync-error';
                document.getElementById('sync-status-info').textContent =
                    'Knowledge sync is disabled. Please enable KNOWLEDGE_SYNC_ENABLED in your environment configuration.';

                document.getElementById('sync-controls').style.display = 'none';
                document.getElementById('folder-list').style.display = 'none';
            }
        } catch (error) {
            document.getElementById('sync-status-info').className = 'sync-status sync-error';
            document.getElementById('sync-status-info').textContent = `Error loading status: ${error.message}`;
        }
    }

    document.getElementById('refresh-sync-status-btn').addEventListener('click', loadSyncStatus);

    document.getElementById('sync-btn').addEventListener('click', function() {
        runSync(false);
    });

    document.getElementById('resync-btn').addEventListener('click', function() {
        runSync(true);
    });

    async function runSync(resync) {
        const button = resync ? document.getElementById('resync-btn') : document.getElementById('sync-btn');
        const loading = resync ? document.getElementById('resync-loading') : document.getElementById('sync-loading');

        button.disabled = true;
        loading.style.display = 'inline';

        try {
            const response = await fetch('/api/knowledge-sync/trigger', {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json'
                },
                body: JSON.stringify({ resync: resync })
            });

            const result = await response.json();
            displaySyncResults(result, resync);
        } catch (error) {
            displaySyncResults({ success: false, error: error.message }, resync);
        } finally {
            button.disabled = false;
            loading.style.display = 'none';
        }
    }

    async function syncSingleFolder(folderPath, collectionName, overwrite) {
        try {
            const response = await fetch('/api/knowledge-sync/folder', {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json'
                },
                body: JSON.stringify({
                    folder_path: folderPath,
                    collection_name: collectionName,
                    overwrite: overwrite
                })
            });

            const result = await response.json();
            displaySyncResults(result, overwrite, `Single folder (${collectionName})`);
        } catch (error) {
            displaySyncResults({ success: false, error: error.message }, overwrite, `Single folder (${collectionName})`);
        }
    }

    function displaySyncResults(result, resync, title = null) {
        const resultsDiv = document.getElementById('sync-results');
        const action = title || (resync ? 'Re-syncing' : 'Syncing');

        let html = `<h3>${action} Results</h3>`;

        if (result.success) {
            html += `<div class="sync-status sync-success">
                ✅ ${action} completed successfully!<br>`;

            if (result.total_folders) {
                html += `Processed ${result.total_folders} folders, `;
                html += `synced ${result.total_imported_files} files.<br>`;
            }

            if (result.imported_files !== undefined) {
                html += `Synced ${result.imported_files} files.<br>`;
            }

            html += `</div>`;

            if (result.results) {
                html += '<h4>Detailed Results:</h4>';
                result.results.forEach(folderResult => {
                    const status = folderResult.success ? 'sync-success' : 'sync-error';
                    html += `<div class="sync-status ${status}">
                        <strong>${folderResult.collection}:</strong> `;

                    if (folderResult.success) {
                        html += `${folderResult.imported_files || 0} files synced`;
                        if (folderResult.warning) {
                            html += ` (${folderResult.warning})`;
                        }
                    } else {
                        html += `Error: ${folderResult.error}`;
                    }

                    html += `</div>`;
                });
            }
        } else {
            html += `<div class="sync-status sync-error">
                ❌ ${action} failed: ${result.error}
            </div>`;
        }

        resultsDiv.innerHTML = html;
    }

    // --- Code Indexing Tab Functions ---
    let selectedIndexingMethod = null;

    // Handle indexing method selection
    document.querySelectorAll('.indexing-option').forEach(option => {
        option.addEventListener('click', function() {
            // Remove previous selection
            document.querySelectorAll('.indexing-option').forEach(opt => opt.classList.remove('selected'));

            // Add selection to clicked option
            this.classList.add('selected');
            selectedIndexingMethod = this.dataset.method;

            // Show/hide method-specific options
            const ctagsOptions = document.getElementById('ctags-options');
            if (selectedIndexingMethod === 'ctags') {
                ctagsOptions.style.display = 'block';
            } else {
                ctagsOptions.style.display = 'none';
            }

            // Enable the start button if we have both path and method
            updateStartButton();
        });
    });

    // Handle source path input
    document.getElementById('source-path-input').addEventListener('input', updateStartButton);

    function updateStartButton() {
        const pathInput = document.getElementById('source-path-input').value.trim();
        const startBtn = document.getElementById('start-indexing-btn');

        if (pathInput && selectedIndexingMethod) {
            startBtn.disabled = false;
            startBtn.style.opacity = '1';
        } else {
            startBtn.disabled = true;
            startBtn.style.opacity = '0.5';
        }
    }

    // Handle indexing start
    document.getElementById('start-indexing-btn').addEventListener('click', async function() {
        const sourcePath = document.getElementById('source-path-input').value.trim();
        const statusDiv = document.getElementById('indexing-status');
        const resultsDiv = document.getElementById('indexing-results');

        if (!sourcePath || !selectedIndexingMethod) {
            statusDiv.innerHTML = '<span style="color:red;">Please select a source path and indexing method.</span>';
            return;
        }

        // Disable button during processing
        const startBtn = this;
        startBtn.disabled = true;
        startBtn.innerHTML = '⏳ Indexing...';

        statusDiv.innerHTML = '<span style="color:blue;">Starting code indexing...</span>';
        resultsDiv.innerHTML = '';

        try {
            let endpoint, requestData;

            if (selectedIndexingMethod === 'ctags') {
                endpoint = '/api/code-indexing/ctags';
                const languages = document.getElementById('languages-input').value.trim();
                requestData = {
                    source_path: sourcePath,
                    languages: languages
                };
            } else if (selectedIndexingMethod === 'tree-sitter') {
                endpoint = '/api/code-indexing/tree-sitter';
                requestData = {
                    source_path: sourcePath
                };
            }

            const response = await fetch(endpoint, {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json'
                },
                body: JSON.stringify(requestData)
            });

            const result = await response.json();

            if (result.success) {
                statusDiv.innerHTML = '<span style="color:green;">✅ Code indexing completed successfully!</span>';
                displayIndexingResults(result);
            } else {
                statusDiv.innerHTML = `<span style="color:red;">❌ Error: ${result.error}</span>`;
            }

        } catch (error) {
            statusDiv.innerHTML = `<span style="color:red;">❌ Unexpected error: ${error.message}</span>`;
        } finally {
            // Re-enable button
            startBtn.disabled = false;
            startBtn.innerHTML = 'Start Indexing';
        }
    });

    function displayIndexingResults(result) {
        const resultsDiv = document.getElementById('indexing-results');
        let html = '<h3>Indexing Results</h3>';

        // Show git information if available
        if (result.git_info) {
            const gitInfo = result.git_info;
            html += `
                <div class="code-indexing-result">
                    <strong>Repository Info:</strong><br>
                    ${gitInfo.is_git_repo ? '📂 Git repository detected' : '📁 Not a git repository'}<br>
                    ${gitInfo.is_git_repo ? `📝 Git tracked files: ${gitInfo.tracked_files_count}<br>` : ''}
                    ${gitInfo.processed_files !== undefined ? `✅ Files processed: ${gitInfo.processed_files}<br>` : ''}
                    ${gitInfo.skipped_files !== undefined && gitInfo.skipped_files > 0 ? `⏭️ Files skipped (not tracked): ${gitInfo.skipped_files}<br>` : ''}
                    ${gitInfo.path_hash ? `🔢 Path hash: ${gitInfo.path_hash}<br>` : ''}
                </div>
            `;
        }

        if (selectedIndexingMethod === 'ctags') {
            html += `
                <div class="code-indexing-result">
                    <strong>CTags Results:</strong><br>
                    📄 Tags generated: ${result.tags_count}<br>
                    📁 Output directory: ${result.output_files.subfolder}<br>
                    📄 Output files:<br>
                    &nbsp;&nbsp;• Tags: ${result.output_files.tags}<br>
                    &nbsp;&nbsp;• Outline: ${result.output_files.outline}<br>
                    &nbsp;&nbsp;• Meta: ${result.output_files.subfolder}/meta.txt
                </div>
            `;

            if (result.outline) {
                html += '<h4>Code Outline Preview:</h4>';
                html += '<div class="code-indexing-result">';
                html += '<pre>' + JSON.stringify(result.outline, null, 2) + '</pre>';
                html += '</div>';
            }

        } else if (selectedIndexingMethod === 'tree-sitter') {
            html += `
                <div class="code-indexing-result">
                    <strong>Tree-Sitter Results:</strong><br>
                    📁 Files parsed: ${result.parsed_files_count}<br>
                    🔧 Functions found: ${result.total_functions}<br>
                    📦 Classes found: ${result.total_classes}<br>
                    📁 Output directory: ${result.output_files.subfolder}<br>
                    📄 Output files:<br>
                    &nbsp;&nbsp;• Analysis: ${result.output_files.tree_sitter}<br>
                    &nbsp;&nbsp;• Meta: ${result.output_files.subfolder}/meta.txt
                </div>
            `;

            if (result.results && result.results.length > 0) {
                html += '<h4>Analysis Preview:</h4>';
                html += '<div class="code-indexing-result">';

                // Show summary of each file
                result.results.slice(0, 5).forEach(file => {
                    html += `<div style="margin-bottom:10px;">
                        <strong>${file.file_path} (${file.language})</strong><br>
                        &nbsp;&nbsp;Functions: ${file.functions ? file.functions.length : 0}<br>
                        &nbsp;&nbsp;Classes: ${file.classes ? file.classes.length : 0}<br>
                    </div>`;
                });

                if (result.results.length > 5) {
                    html += `<div>... and ${result.results.length - 5} more files</div>`;
                }

                html += '</div>';
            }
        }

        resultsDiv.innerHTML = html;
    }

    // --- Code Viewer Tab Functions ---
    let cvIndexedPaths = [];
    let cvSelectedPath = null;
    let cvAllClasses = [];
    let cvOriginalPath = null;

    async function loadCodeViewerPaths() {
        const loadingDiv = document.getElementById('cv-paths-loading');
        const errorDiv = document.getElementById('cv-paths-error');
        const containerDiv = document.getElementById('cv-paths-container');

        try {
            // Fetch available indexed paths
            const response = await fetch('/api/code-viewer/paths');
            const data = await response.json();

            if (data.success) {
                cvIndexedPaths = data.paths;
                displayCodeViewerPaths();

                loadingDiv.style.display = 'none';
                containerDiv.style.display = 'block';
            } else {
                throw new Error(data.error || 'Failed to load paths');
            }
        } catch (error) {
            console.error('Error loading paths:', error);
            loadingDiv.style.display = 'none';
            errorDiv.style.display = 'block';
            errorDiv.textContent = `❌ Error loading paths: ${error.message}`;
        }
    }

    function displayCodeViewerPaths() {
        const pathsList = document.getElementById('cv-indexed-paths');

        if (cvIndexedPaths.length === 0) {
            pathsList.innerHTML = `
                <div class="no-results">
                    No indexed paths found. Please index some code first using the Code Indexing tab.
                </div>
            `;
            return;
        }

        const pathsHtml = cvIndexedPaths.map(path => `
            <div class="path-item" onclick="selectCodeViewerPath('${path.hash}')">
                <div class="path-original">${path.original_path}</div>
                <div class="path-meta">
                    Hash: ${path.hash} | Created: ${new Date(path.created).toLocaleString()}
                </div>
            </div>
        `).join('');

        pathsList.innerHTML = pathsHtml;
    }

    async function selectCodeViewerPath(hash) {
        // Update UI selection
        document.querySelectorAll('#cv-indexed-paths .path-item').forEach(item => {
            item.classList.remove('selected');
        });
        event.target.closest('.path-item').classList.add('selected');

        // Find the selected path
        cvSelectedPath = cvIndexedPaths.find(p => p.hash === hash);

        // Show path details
        displayCodeViewerPathDetails(cvSelectedPath);

        // Load class data for the selected path
        await loadCodeViewerClassData(hash);

        // Show search section
        document.getElementById('cv-search-section').style.display = 'block';
    }

    function displayCodeViewerPathDetails(path) {
        const detailsDiv = document.getElementById('cv-path-details');
        const infoDiv = document.getElementById('cv-selected-path-info');

        detailsDiv.innerHTML = `
            <div class="path-meta">
                <strong>Original Path:</strong> <code>${path.original_path}</code><br>
                <strong>Hash:</strong> <code>${path.hash}</code><br>
                <strong>Created:</strong> ${new Date(path.created).toLocaleString()}<br>
                <strong>Classes Available:</strong> ${path.class_count || 'Loading...'}
            </div>
        `;

        infoDiv.style.display = 'block';
    }

    async function loadCodeViewerClassData(hash) {
        try {
            const response = await fetch(`/api/code-viewer/classes/${hash}`);
            const data = await response.json();

            if (data.success) {
                cvAllClasses = data.classes;
                cvOriginalPath = data.original_path;

                // Update path details with class count
                const path = cvIndexedPaths.find(p => p.hash === hash);
                if (path) {
                    path.class_count = cvAllClasses.length;
                    displayCodeViewerPathDetails(path);
                }

                // Update search stats
                const statsDiv = document.getElementById('cv-search-stats');
                statsDiv.innerHTML = `📊 ${cvAllClasses.length} classes available for search`;
                statsDiv.style.display = 'block';

                // Clear previous search
                clearCodeViewerSearchResults();
            } else {
                throw new Error(data.error || 'Failed to load class data');
            }
        } catch (error) {
            console.error('Error loading class data:', error);
            document.getElementById('cv-search-results').innerHTML = `
                <div class="error">Error loading class data: ${error.message}</div>
            `;
        }
    }

    // Search functionality
    document.getElementById('cv-class-search-input').addEventListener('input', function(e) {
        const query = e.target.value.trim().toLowerCase();

        if (!cvSelectedPath) {
            return;
        }

        if (query === '') {
            clearCodeViewerSearchResults();
            return;
        }

        searchCodeViewerClasses(query);
    });

    function searchCodeViewerClasses(query) {
        if (!cvAllClasses || cvAllClasses.length === 0) {
            document.getElementById('cv-search-results').innerHTML = `
                <div class="no-results">No class data available</div>
            `;
            return;
        }

        // Filter classes based on query (search both name and file path)
        const matchedClasses = cvAllClasses.filter(classInfo =>
            classInfo.name.toLowerCase().includes(query) ||
            classInfo.file_path.toLowerCase().includes(query)
        ).slice(0, 20); // Limit to top 20 results

        if (matchedClasses.length === 0) {
            document.getElementById('cv-search-results').innerHTML = `
                <div class="no-results">No classes found matching "${query}"</div>
            `;
            return;
        }

        displayCodeViewerSearchResults(matchedClasses, query);
    }

    function displayCodeViewerSearchResults(classes, query) {
        const resultsDiv = document.getElementById('cv-search-results');

        const resultsHtml = classes.map(classInfo => {
            // Generate UML-like representation with members
            const umlDiagram = generateCodeViewerUMLDiagram(classInfo.name, classInfo.members || []);

            // Format file path display
            const filePathDisplay = classInfo.file_path === 'Unknown' ?
                '<em>File path not available</em>' :
                `<code>${highlightCodeViewerText(classInfo.file_path, query)}</code>`;

            // Add line number if available
            const lineInfo = classInfo.line > 0 ? ` (line ${classInfo.line})` : '';

            // Show member count
            const memberCount = classInfo.members ? classInfo.members.length : 0;
            const memberInfo = memberCount > 0 ? ` (${memberCount} members)` : '';

            return `
                <div class="class-card">
                    <div class="class-name">${highlightCodeViewerText(classInfo.name, query)}${memberInfo}</div>
                    <div class="class-info">
                        <strong>📁 File:</strong> ${filePathDisplay} ${lineInfo ? `<span class="line-number">${lineInfo}</span>` : ''}<br>
                        <strong>🔧 Source:</strong> <span class="source-badge">${classInfo.source || 'Unknown'}</span><br>
                        <strong>📦 Project:</strong> <code>${cvOriginalPath || cvSelectedPath.original_path}</code>
                    </div>
                    <div class="uml-diagram">
${umlDiagram}
                    </div>
                </div>
            `;
        }).join('');

        resultsDiv.innerHTML = resultsHtml;
    }

    function generateCodeViewerUMLDiagram(className, members = []) {
        // Generate a UML-like text representation with actual members and expandable sections
        const cleanName = className.replace(/^__anon[a-f0-9]+/, 'Anonymous');
        const uniqueId = `cv_uml_${Math.random().toString(36).substr(2, 9)}`;

        // Calculate box width based on content
        const maxNameLength = Math.max(
            cleanName.length,
            ...members.map(m => formatCodeViewerMemberForUML(m).length)
        );
        const boxWidth = Math.max(30, maxNameLength + 6); // Minimum 30 chars

        // Create borders
        const topBorder = `┌─ ${cleanName} ─${'─'.repeat(boxWidth - cleanName.length - 4)}┐`;
        const separator = `├${'─'.repeat(boxWidth - 2)}┤`;
        const bottomBorder = `└${'─'.repeat(boxWidth - 2)}┘`;

        // Start building the diagram
        let diagramHtml = '';

        // Add namespace info if present
        if (className.includes('::')) {
            const parts = className.split('::');
            const namespace = parts.slice(0, -1).join('::');
            diagramHtml += `🏛️  Namespace: ${namespace}\n\n`;
        }

        diagramHtml += topBorder + '\n';

        // Add members
        if (members.length > 0) {
            diagramHtml += separator + '\n';

            // Separate methods and variables
            const methods = members.filter(m => m.kind === 'member' || m.kind === 'method' || m.kind === 'function');
            const variables = members.filter(m => m.kind === 'variable');

            // Add methods (show first 8, with expandable section for the rest)
            const displayMethods = methods.slice(0, 8);
            displayMethods.forEach(member => {
                const memberText = formatCodeViewerMemberForUML(member);
                const padding = ' '.repeat(Math.max(0, boxWidth - memberText.length - 2));
                diagramHtml += `│ ${memberText}${padding}│\n`;
            });

            // Create expandable section for additional methods
            if (methods.length > 8) {
                const remainingMethods = methods.slice(8);
                const moreCount = remainingMethods.length;

                // Container for both expand toggle and expanded content
                diagramHtml += `<div id="${uniqueId}_methods_container">`;

                // Show expandable toggle (visible by default)
                const expandText = `... and ${moreCount} more methods`;
                const expandPadding = ' '.repeat(Math.max(0, boxWidth - expandText.length - 2));
                diagramHtml += `<div id="${uniqueId}_methods_toggle" class="uml-toggle-section">`;
                diagramHtml += `│ <span class="uml-expand-toggle" onclick="toggleCodeViewerUMLSection('${uniqueId}_methods')">${expandText}</span>${expandPadding}│\n`;
                diagramHtml += `</div>`;

                // Hidden expanded section
                diagramHtml += `<div id="${uniqueId}_methods" class="uml-expanded-section">`;
                remainingMethods.forEach(member => {
                    const memberText = formatCodeViewerMemberForUML(member);
                    const padding = ' '.repeat(Math.max(0, boxWidth - memberText.length - 2));
                    diagramHtml += `│ ${memberText}${padding}│\n`;
                });

                // Add collapse toggle
                const collapseText = `click to collapse ${moreCount} methods`;
                const collapsePadding = ' '.repeat(Math.max(0, boxWidth - collapseText.length - 2));
                diagramHtml += `│ <span class="uml-collapse-toggle" onclick="toggleCodeViewerUMLSection('${uniqueId}_methods')">${collapseText}</span>${collapsePadding}│\n`;
                diagramHtml += '</div>';

                diagramHtml += '</div>';
            }

            // Add separator if we have both methods and variables
            if (methods.length > 0 && variables.length > 0) {
                diagramHtml += separator + '\n';
            }

            // Add variables (show first 5, with expandable section for the rest)
            const displayVars = variables.slice(0, 5);
            displayVars.forEach(member => {
                const memberText = formatCodeViewerMemberForUML(member);
                const padding = ' '.repeat(Math.max(0, boxWidth - memberText.length - 2));
                diagramHtml += `│ ${memberText}${padding}│\n`;
            });

            // Create expandable section for additional variables
            if (variables.length > 5) {
                const remainingVars = variables.slice(5);
                const moreCount = remainingVars.length;

                // Container for both expand toggle and expanded content
                diagramHtml += `<div id="${uniqueId}_vars_container">`;

                // Show expandable toggle (visible by default)
                const expandText = `... and ${moreCount} more attributes`;
                const expandPadding = ' '.repeat(Math.max(0, boxWidth - expandText.length - 2));
                diagramHtml += `<div id="${uniqueId}_vars_toggle" class="uml-toggle-section">`;
                diagramHtml += `│ <span class="uml-expand-toggle" onclick="toggleCodeViewerUMLSection('${uniqueId}_vars')">${expandText}</span>${expandPadding}│\n`;
                diagramHtml += `</div>`;

                // Hidden expanded section
                diagramHtml += `<div id="${uniqueId}_vars" class="uml-expanded-section">`;
                remainingVars.forEach(member => {
                    const memberText = formatCodeViewerMemberForUML(member);
                    const padding = ' '.repeat(Math.max(0, boxWidth - memberText.length - 2));
                    diagramHtml += `│ ${memberText}${padding}│\n`;
                });

                // Add collapse toggle
                const collapseText = `click to collapse ${moreCount} attributes`;
                const collapsePadding = ' '.repeat(Math.max(0, boxWidth - collapseText.length - 2));
                diagramHtml += `│ <span class="uml-collapse-toggle" onclick="toggleCodeViewerUMLSection('${uniqueId}_vars')">${collapseText}</span>${collapsePadding}│\n`;
                diagramHtml += '</div>';

                diagramHtml += '</div>';
            }
        } else {
            // Empty class or no member info
            diagramHtml += separator + '\n';
            const emptyText = '(no member info)';
            const padding = ' '.repeat(Math.max(0, boxWidth - emptyText.length - 2));
            diagramHtml += `│ ${emptyText}${padding}│\n`;
        }

        diagramHtml += bottomBorder;

        return diagramHtml;
    }

    function formatCodeViewerMemberForUML(member) {
        // Format member for UML display
        const accessSymbol = member.access === 'private' ? '-' :
                           member.access === 'protected' ? '#' : '+';

        let memberText = `${accessSymbol} ${member.name}`;

        // For methods, show simplified signature
        if (member.kind === 'member' || member.kind === 'method' || member.kind === 'function') {
            if (member.signature && member.signature.includes('(')) {
                // Extract parameter list - simplified
                const params = extractCodeViewerSimpleParams(member.signature);
                memberText += `(${params})`;
            } else {
                memberText += '()';
            }
        }

        // Limit length to keep UML readable
        if (memberText.length > 40) {
            memberText = memberText.substring(0, 37) + '...';
        }

        return memberText;
    }

    function extractCodeViewerSimpleParams(signature) {
        // Extract and simplify parameter list
        const match = signature.match(/\(([^)]*)\)/);
        if (!match) return '';

        const params = match[1];
        if (!params || params.trim() === 'self' || params.trim() === '') return '';

        // Simplify complex parameter lists
        const paramList = params.split(',').map(p => {
            const trimmed = p.trim();
            // Just get the parameter name (after the last space)
            const parts = trimmed.split(/\s+/);
            return parts[parts.length - 1].replace(/[=].*/, ''); // Remove default values
        }).filter(p => p && p !== 'self');

        // Limit number of parameters shown
        if (paramList.length > 3) {
            return paramList.slice(0, 3).join(', ') + '...';
        }

        return paramList.join(', ');
    }

    // Function to toggle UML expandable sections
    function toggleCodeViewerUMLSection(sectionId) {
        const expandedSection = document.getElementById(sectionId);
        const toggleSection = document.getElementById(sectionId + '_toggle');

        if (expandedSection && toggleSection) {
            if (expandedSection.classList.contains('visible')) {
                // Hide expanded, show toggle
                expandedSection.classList.remove('visible');
                toggleSection.classList.remove('hidden');
            } else {
                // Show expanded, hide toggle
                expandedSection.classList.add('visible');
                toggleSection.classList.add('hidden');
            }
        }
    }

    // Make toggleCodeViewerUMLSection globally available
    window.toggleCodeViewerUMLSection = toggleCodeViewerUMLSection;

    function highlightCodeViewerText(text, query) {
        if (!query) return text;

        const regex = new RegExp(`(${query})`, 'gi');
        return text.replace(regex, '<mark style="background-color: #fff3cd; padding: 2px 4px; border-radius: 2px;">$1</mark>');
    }

    function clearCodeViewerSearchResults() {
        document.getElementById('cv-search-results').innerHTML = `
            <div class="no-results" id="cv-no-search-message">
                Enter a class name above to search for definitions
            </div>
        `;
    }
</script>
{% endblock %}
