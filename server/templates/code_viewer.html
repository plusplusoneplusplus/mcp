{% extends "base.html" %}

{% block title %}Code Viewer - MCP Knowledge Server{% endblock %}

{% block extra_styles %}
<style>
    /* Code viewer specific styles */
    .path-selector {
        background-color: #f8f9fa;
        border: 1px solid #dee2e6;
        border-radius: 8px;
        padding: 20px;
        margin-bottom: 20px;
    }

    .indexed-paths-list {
        max-height: 300px;
        overflow-y: auto;
        border: 1px solid #ddd;
        border-radius: 4px;
        margin: 10px 0;
    }

    .path-item {
        padding: 12px 15px;
        border-bottom: 1px solid #eee;
        cursor: pointer;
        transition: background-color 0.2s;
    }

    .path-item:hover {
        background-color: #f0f8ff;
    }

    .path-item.selected {
        background-color: #e7f3ff;
        border-left: 4px solid #0077cc;
    }

    .path-item:last-child {
        border-bottom: none;
    }

    .path-original {
        font-family: monospace;
        font-weight: bold;
        color: #0077cc;
        font-size: 1.1em;
    }

    .path-meta {
        font-size: 0.85em;
        color: #666;
        margin-top: 4px;
    }

    .search-section {
        background-color: white;
        border: 1px solid #dee2e6;
        border-radius: 8px;
        padding: 20px;
        margin-bottom: 20px;
    }

    .search-input {
        width: 100%;
        padding: 10px 15px;
        border: 2px solid #ddd;
        border-radius: 6px;
        font-size: 1em;
        transition: border-color 0.2s;
    }

    .search-input:focus {
        outline: none;
        border-color: #0077cc;
        box-shadow: 0 0 0 3px rgba(0, 119, 204, 0.1);
    }

    .file-path {
        font-family: monospace;
        background-color: #f1f3f4;
        padding: 2px 6px;
        border-radius: 3px;
        font-size: 0.9em;
    }

    .line-number {
        color: #666;
        font-size: 0.85em;
    }

    .source-badge {
        display: inline-block;
        background-color: #e1f5fe;
        color: #0277bd;
        padding: 2px 8px;
        border-radius: 12px;
        font-size: 0.8em;
        font-weight: bold;
        text-transform: capitalize;
    }

    .uml-expand-toggle {
        cursor: pointer;
        color: #0077cc;
        text-decoration: underline;
        font-style: italic;
        user-select: none;
        transition: color 0.2s;
    }

    .uml-expand-toggle:hover {
        color: #005aa3;
        background-color: rgba(0, 119, 204, 0.1);
        padding: 2px 4px;
        border-radius: 3px;
    }

    .uml-expanded-section {
        display: none;
    }

    .uml-expanded-section.visible {
        display: block;
    }

    .uml-collapse-toggle {
        cursor: pointer;
        color: #666;
        text-decoration: underline;
        font-style: italic;
        user-select: none;
        transition: color 0.2s;
    }

    .uml-collapse-toggle:hover {
        color: #333;
    }

    .uml-toggle-section {
        display: block;
    }

    .uml-toggle-section.hidden {
        display: none;
    }

    .class-results {
        margin-top: 20px;
    }

    .class-card {
        background: white;
        border: 1px solid #dee2e6;
        border-radius: 8px;
        padding: 15px;
        margin-bottom: 15px;
        box-shadow: 0 2px 4px rgba(0,0,0,0.1);
    }

    .class-name {
        font-family: monospace;
        font-size: 1.2em;
        font-weight: bold;
        color: #0077cc;
        margin-bottom: 8px;
    }

    .class-info {
        font-size: 0.9em;
        color: #666;
        margin-bottom: 10px;
    }

    .uml-diagram {
        background: #f8f9fa;
        border: 1px solid #dee2e6;
        border-radius: 4px;
        padding: 15px;
        font-family: monospace;
        font-size: 0.9em;
        white-space: pre-wrap;
        max-height: 400px;
        overflow-y: auto;
    }

    .no-results {
        text-align: center;
        padding: 40px;
        color: #666;
        font-style: italic;
    }

    .loading {
        text-align: center;
        padding: 20px;
        color: #0077cc;
    }

    .error {
        background-color: #f8d7da;
        border: 1px solid #f5c6cb;
        color: #721c24;
        padding: 15px;
        border-radius: 4px;
        margin: 10px 0;
    }

    .search-stats {
        background-color: #d1ecf1;
        border: 1px solid #bee5eb;
        color: #0c5460;
        padding: 10px;
        border-radius: 4px;
        margin: 10px 0;
        font-size: 0.9em;
    }
</style>
{% endblock %}

{% block content %}
<h1>Code Viewer</h1>
<p>Browse indexed code repositories and search for class definitions with UML-like visualization.</p>

<!-- Path Selection Section -->
<div class="path-selector">
    <h2>üìÅ Select Indexed Path</h2>
    <p>Choose from the indexed code repositories below:</p>

    <div id="paths-loading" class="loading">
        ‚è≥ Loading indexed paths...
    </div>

    <div id="paths-error" class="error" style="display: none;">
        ‚ùå Error loading paths
    </div>

    <div id="paths-container" style="display: none;">
        <div class="indexed-paths-list" id="indexed-paths">
            <!-- Paths will be populated here -->
        </div>

        <div id="selected-path-info" style="display: none;">
            <h3>Selected Path Information:</h3>
            <div id="path-details"></div>
        </div>
    </div>
</div>

<!-- Class Search Section -->
<div class="search-section" id="search-section" style="display: none;">
    <h2>üîç Search Class Definitions</h2>
    <p>Search for classes in the selected codebase:</p>

    <input type="text"
           id="class-search-input"
           class="search-input"
           placeholder="Search classes by name or file path (e.g., 'RedisModule', 'Table', '.py', 'utils/')"
           autocomplete="off">

    <div id="search-stats" class="search-stats" style="display: none;"></div>

    <div id="search-results" class="class-results">
        <div class="no-results" id="no-search-message">
            Enter a class name above to search for definitions
        </div>
    </div>
</div>
{% endblock %}

{% block extra_scripts %}
<script>
    let indexedPaths = [];
    let selectedPath = null;
    let allClasses = [];
    let originalPath = null;

    // Load indexed paths on page load
    document.addEventListener('DOMContentLoaded', function() {
        loadIndexedPaths();
    });

    async function loadIndexedPaths() {
        const loadingDiv = document.getElementById('paths-loading');
        const errorDiv = document.getElementById('paths-error');
        const containerDiv = document.getElementById('paths-container');

        try {
            // Fetch available indexed paths
            const response = await fetch('/api/code-viewer/paths');
            const data = await response.json();

            if (data.success) {
                indexedPaths = data.paths;
                displayIndexedPaths();

                loadingDiv.style.display = 'none';
                containerDiv.style.display = 'block';
            } else {
                throw new Error(data.error || 'Failed to load paths');
            }
        } catch (error) {
            console.error('Error loading paths:', error);
            loadingDiv.style.display = 'none';
            errorDiv.style.display = 'block';
            errorDiv.textContent = `‚ùå Error loading paths: ${error.message}`;
        }
    }

    function displayIndexedPaths() {
        const pathsList = document.getElementById('indexed-paths');

        if (indexedPaths.length === 0) {
            pathsList.innerHTML = `
                <div class="no-results">
                    No indexed paths found. Please index some code first using the Code Indexing tab.
                </div>
            `;
            return;
        }

        const pathsHtml = indexedPaths.map(path => `
            <div class="path-item" onclick="selectPath('${path.hash}')">
                <div class="path-original">${path.original_path}</div>
                <div class="path-meta">
                    Hash: ${path.hash} | Created: ${new Date(path.created).toLocaleString()}
                </div>
            </div>
        `).join('');

        pathsList.innerHTML = pathsHtml;
    }

    async function selectPath(hash) {
        // Update UI selection
        document.querySelectorAll('.path-item').forEach(item => {
            item.classList.remove('selected');
        });
        event.target.closest('.path-item').classList.add('selected');

        // Find the selected path
        selectedPath = indexedPaths.find(p => p.hash === hash);

        // Show path details
        displayPathDetails(selectedPath);

        // Load class data for the selected path
        await loadClassData(hash);

        // Show search section
        document.getElementById('search-section').style.display = 'block';
    }

    function displayPathDetails(path) {
        const detailsDiv = document.getElementById('path-details');
        const infoDiv = document.getElementById('selected-path-info');

        detailsDiv.innerHTML = `
            <div class="path-meta">
                <strong>Original Path:</strong> <code>${path.original_path}</code><br>
                <strong>Hash:</strong> <code>${path.hash}</code><br>
                <strong>Created:</strong> ${new Date(path.created).toLocaleString()}<br>
                <strong>Classes Available:</strong> ${path.class_count || 'Loading...'}
            </div>
        `;

        infoDiv.style.display = 'block';
    }

    async function loadClassData(hash) {
        try {
            const response = await fetch(`/api/code-viewer/classes/${hash}`);
            const data = await response.json();

            if (data.success) {
                allClasses = data.classes;
                originalPath = data.original_path;

                // Update path details with class count
                const path = indexedPaths.find(p => p.hash === hash);
                if (path) {
                    path.class_count = allClasses.length;
                    displayPathDetails(path);
                }

                // Update search stats
                const statsDiv = document.getElementById('search-stats');
                statsDiv.innerHTML = `üìä ${allClasses.length} classes available for search`;
                statsDiv.style.display = 'block';

                // Clear previous search
                clearSearchResults();
            } else {
                throw new Error(data.error || 'Failed to load class data');
            }
        } catch (error) {
            console.error('Error loading class data:', error);
            document.getElementById('search-results').innerHTML = `
                <div class="error">Error loading class data: ${error.message}</div>
            `;
        }
    }

    // Search functionality
    document.getElementById('class-search-input').addEventListener('input', function(e) {
        const query = e.target.value.trim().toLowerCase();

        if (!selectedPath) {
            return;
        }

        if (query === '') {
            clearSearchResults();
            return;
        }

        searchClasses(query);
    });

    function searchClasses(query) {
        if (!allClasses || allClasses.length === 0) {
            document.getElementById('search-results').innerHTML = `
                <div class="no-results">No class data available</div>
            `;
            return;
        }

        // Filter classes based on query (search both name and file path)
        const matchedClasses = allClasses.filter(classInfo =>
            classInfo.name.toLowerCase().includes(query) ||
            classInfo.file_path.toLowerCase().includes(query)
        ).slice(0, 20); // Limit to top 20 results

        if (matchedClasses.length === 0) {
            document.getElementById('search-results').innerHTML = `
                <div class="no-results">No classes found matching "${query}"</div>
            `;
            return;
        }

        displaySearchResults(matchedClasses, query);
    }

    function displaySearchResults(classes, query) {
        const resultsDiv = document.getElementById('search-results');

        const resultsHtml = classes.map(classInfo => {
            // Generate UML-like representation with members
            const umlDiagram = generateUMLDiagram(classInfo.name, classInfo.members || []);

            // Format file path display
            const filePathDisplay = classInfo.file_path === 'Unknown' ?
                '<em>File path not available</em>' :
                `<code>${highlightText(classInfo.file_path, query)}</code>`;

            // Add line number if available
            const lineInfo = classInfo.line > 0 ? ` (line ${classInfo.line})` : '';

            // Show member count
            const memberCount = classInfo.members ? classInfo.members.length : 0;
            const memberInfo = memberCount > 0 ? ` (${memberCount} members)` : '';

            return `
                <div class="class-card">
                    <div class="class-name">${highlightText(classInfo.name, query)}${memberInfo}</div>
                    <div class="class-info">
                        <strong>üìÅ File:</strong> ${filePathDisplay} ${lineInfo ? `<span class="line-number">${lineInfo}</span>` : ''}<br>
                        <strong>üîß Source:</strong> <span class="source-badge">${classInfo.source || 'Unknown'}</span><br>
                        <strong>üì¶ Project:</strong> <code>${originalPath || selectedPath.original_path}</code>
                    </div>
                    <div class="uml-diagram">
${umlDiagram}
                    </div>
                </div>
            `;
        }).join('');

        resultsDiv.innerHTML = resultsHtml;
    }

    function generateUMLDiagram(className, members = []) {
        // Generate a UML-like text representation with actual members and expandable sections
        const cleanName = className.replace(/^__anon[a-f0-9]+/, 'Anonymous');
        const uniqueId = `uml_${Math.random().toString(36).substr(2, 9)}`;

        // Calculate box width based on content
        const maxNameLength = Math.max(
            cleanName.length,
            ...members.map(m => formatMemberForUML(m).length)
        );
        const boxWidth = Math.max(30, maxNameLength + 6); // Minimum 30 chars

        // Create borders
        const topBorder = `‚îå‚îÄ ${cleanName} ‚îÄ${'‚îÄ'.repeat(boxWidth - cleanName.length - 4)}‚îê`;
        const separator = `‚îú${'‚îÄ'.repeat(boxWidth - 2)}‚î§`;
        const bottomBorder = `‚îî${'‚îÄ'.repeat(boxWidth - 2)}‚îò`;

        // Start building the diagram
        let diagramHtml = '';

        // Add namespace info if present
        if (className.includes('::')) {
            const parts = className.split('::');
            const namespace = parts.slice(0, -1).join('::');
            diagramHtml += `üèõÔ∏è  Namespace: ${namespace}\n\n`;
        }

        diagramHtml += topBorder + '\n';

        // Add members
        if (members.length > 0) {
            diagramHtml += separator + '\n';

            // Separate methods and variables
            const methods = members.filter(m => m.kind === 'member' || m.kind === 'method' || m.kind === 'function');
            const variables = members.filter(m => m.kind === 'variable');

            // Add methods (show first 8, with expandable section for the rest)
            const displayMethods = methods.slice(0, 8);
            displayMethods.forEach(member => {
                const memberText = formatMemberForUML(member);
                const padding = ' '.repeat(Math.max(0, boxWidth - memberText.length - 2));
                diagramHtml += `‚îÇ ${memberText}${padding}‚îÇ\n`;
            });

            // Create expandable section for additional methods
            if (methods.length > 8) {
                const remainingMethods = methods.slice(8);
                const moreCount = remainingMethods.length;

                // Container for both expand toggle and expanded content
                diagramHtml += `<div id="${uniqueId}_methods_container">`;

                // Show expandable toggle (visible by default)
                const expandText = `... and ${moreCount} more methods`;
                const expandPadding = ' '.repeat(Math.max(0, boxWidth - expandText.length - 2));
                diagramHtml += `<div id="${uniqueId}_methods_toggle" class="uml-toggle-section">`;
                diagramHtml += `‚îÇ <span class="uml-expand-toggle" onclick="toggleUMLSection('${uniqueId}_methods')">${expandText}</span>${expandPadding}‚îÇ\n`;
                diagramHtml += `</div>`;

                // Hidden expanded section
                diagramHtml += `<div id="${uniqueId}_methods" class="uml-expanded-section">`;
                remainingMethods.forEach(member => {
                    const memberText = formatMemberForUML(member);
                    const padding = ' '.repeat(Math.max(0, boxWidth - memberText.length - 2));
                    diagramHtml += `‚îÇ ${memberText}${padding}‚îÇ\n`;
                });

                // Add collapse toggle
                const collapseText = `click to collapse ${moreCount} methods`;
                const collapsePadding = ' '.repeat(Math.max(0, boxWidth - collapseText.length - 2));
                diagramHtml += `‚îÇ <span class="uml-collapse-toggle" onclick="toggleUMLSection('${uniqueId}_methods')">${collapseText}</span>${collapsePadding}‚îÇ\n`;
                diagramHtml += '</div>';

                diagramHtml += '</div>';
            }

            // Add separator if we have both methods and variables
            if (methods.length > 0 && variables.length > 0) {
                diagramHtml += separator + '\n';
            }

            // Add variables (show first 5, with expandable section for the rest)
            const displayVars = variables.slice(0, 5);
            displayVars.forEach(member => {
                const memberText = formatMemberForUML(member);
                const padding = ' '.repeat(Math.max(0, boxWidth - memberText.length - 2));
                diagramHtml += `‚îÇ ${memberText}${padding}‚îÇ\n`;
            });

            // Create expandable section for additional variables
            if (variables.length > 5) {
                const remainingVars = variables.slice(5);
                const moreCount = remainingVars.length;

                // Container for both expand toggle and expanded content
                diagramHtml += `<div id="${uniqueId}_vars_container">`;

                // Show expandable toggle (visible by default)
                const expandText = `... and ${moreCount} more attributes`;
                const expandPadding = ' '.repeat(Math.max(0, boxWidth - expandText.length - 2));
                diagramHtml += `<div id="${uniqueId}_vars_toggle" class="uml-toggle-section">`;
                diagramHtml += `‚îÇ <span class="uml-expand-toggle" onclick="toggleUMLSection('${uniqueId}_vars')">${expandText}</span>${expandPadding}‚îÇ\n`;
                diagramHtml += `</div>`;

                // Hidden expanded section
                diagramHtml += `<div id="${uniqueId}_vars" class="uml-expanded-section">`;
                remainingVars.forEach(member => {
                    const memberText = formatMemberForUML(member);
                    const padding = ' '.repeat(Math.max(0, boxWidth - memberText.length - 2));
                    diagramHtml += `‚îÇ ${memberText}${padding}‚îÇ\n`;
                });

                // Add collapse toggle
                const collapseText = `click to collapse ${moreCount} attributes`;
                const collapsePadding = ' '.repeat(Math.max(0, boxWidth - collapseText.length - 2));
                diagramHtml += `‚îÇ <span class="uml-collapse-toggle" onclick="toggleUMLSection('${uniqueId}_vars')">${collapseText}</span>${collapsePadding}‚îÇ\n`;
                diagramHtml += '</div>';

                diagramHtml += '</div>';
            }
        } else {
            // Empty class or no member info
            diagramHtml += separator + '\n';
            const emptyText = '(no member info)';
            const padding = ' '.repeat(Math.max(0, boxWidth - emptyText.length - 2));
            diagramHtml += `‚îÇ ${emptyText}${padding}‚îÇ\n`;
        }

        diagramHtml += bottomBorder;

        return diagramHtml;
    }

    function formatMemberForUML(member) {
        // Format member for UML display
        const accessSymbol = member.access === 'private' ? '-' :
                           member.access === 'protected' ? '#' : '+';

        let memberText = `${accessSymbol} ${member.name}`;

        // For methods, show simplified signature
        if (member.kind === 'member' || member.kind === 'method' || member.kind === 'function') {
            if (member.signature && member.signature.includes('(')) {
                // Extract parameter list - simplified
                const params = extractSimpleParams(member.signature);
                memberText += `(${params})`;
            } else {
                memberText += '()';
            }
        }

        // Limit length to keep UML readable
        if (memberText.length > 40) {
            memberText = memberText.substring(0, 37) + '...';
        }

        return memberText;
    }

    function extractSimpleParams(signature) {
        // Extract and simplify parameter list
        const match = signature.match(/\(([^)]*)\)/);
        if (!match) return '';

        const params = match[1];
        if (!params || params.trim() === 'self' || params.trim() === '') return '';

        // Simplify complex parameter lists
        const paramList = params.split(',').map(p => {
            const trimmed = p.trim();
            // Just get the parameter name (after the last space)
            const parts = trimmed.split(/\s+/);
            return parts[parts.length - 1].replace(/[=].*/, ''); // Remove default values
        }).filter(p => p && p !== 'self');

        // Limit number of parameters shown
        if (paramList.length > 3) {
            return paramList.slice(0, 3).join(', ') + '...';
        }

        return paramList.join(', ');
    }

    // Function to toggle UML expandable sections
    function toggleUMLSection(sectionId) {
        const expandedSection = document.getElementById(sectionId);
        const toggleSection = document.getElementById(sectionId + '_toggle');

        if (expandedSection && toggleSection) {
            if (expandedSection.classList.contains('visible')) {
                // Hide expanded, show toggle
                expandedSection.classList.remove('visible');
                toggleSection.classList.remove('hidden');
            } else {
                // Show expanded, hide toggle
                expandedSection.classList.add('visible');
                toggleSection.classList.add('hidden');
            }
        }
    }

    // Make toggleUMLSection globally available
    window.toggleUMLSection = toggleUMLSection;

    function highlightText(text, query) {
        if (!query) return text;

        const regex = new RegExp(`(${query})`, 'gi');
        return text.replace(regex, '<mark style="background-color: #fff3cd; padding: 2px 4px; border-radius: 2px;">$1</mark>');
    }

    function clearSearchResults() {
        document.getElementById('search-results').innerHTML = `
            <div class="no-results" id="no-search-message">
                Enter a class name above to search for definitions
            </div>
        `;
    }
</script>
{% endblock %}
